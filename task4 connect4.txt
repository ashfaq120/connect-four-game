<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Connect 4 — HTML · CSS · JS</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <main class="app">
    <header class="topbar">
      <h1>Connect 4</h1>
      <div class="controls">
        <div class="turn-indicator">
          Turn: <span id="playerName">Red</span>
        </div>
        <button id="resetBtn" class="btn">Reset</button>
      </div>
    </header>

    <section class="board-wrap">
      <div id="board" class="board" aria-label="Connect 4 board" role="grid"></div>
    </section>

    <footer class="footer">
      <div class="message" id="message"></div>
      <div class="legend">
        <span class="dot red"></span> Player 1 (Red)
        <span class="dot yellow"></span> Player 2 (Yellow)
      </div>
    </footer>
  </main>

  <script src="script.js"></script>
  <style>
    :root{
  --cols: 7;
  --rows: 6;
  --cell-size: 64px; /* base, scaled with viewport */
  --board-gap: 8px;
  --bg: #0b1220;
  --panel: #0f1724;
  --accent: #7dd3fc;
}

*{box-sizing:border-box}
html,body{height:100%}
body{
  margin:0;
  font-family:Inter,system-ui,Segoe UI,Roboto, "Helvetica Neue", Arial;
  background: linear-gradient(180deg,#041025 0%, #07243b 100%);
  color:#e6eef6;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:20px;
}

.app{
  width:min(980px,96vw);
  background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:12px;
  padding:18px;
  box-shadow: 0 6px 30px rgba(2,6,23,0.6);
}

/* header */
.topbar{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:12px;
  margin-bottom:12px;
}
.topbar h1{
  margin:0;
  font-size:20px;
  letter-spacing:0.6px;
}
.controls{
  display:flex;
  align-items:center;
  gap:12px;
}
.turn-indicator{
  padding:6px 10px;
  border-radius:8px;
  background:rgba(255,255,255,0.02);
  font-size:14px;
}
.btn{
  background:transparent;
  border:1px solid rgba(255,255,255,0.06);
  color:inherit;
  padding:6px 10px;
  border-radius:8px;
  cursor:pointer;
  transition:all .18s ease;
}
.btn:hover{transform:translateY(-2px);}

/* board area */
.board-wrap{
  display:flex;
  justify-content:center;
  padding:12px;
}
.board{
  --cell: var(--cell-size);
  display:grid;
  grid-template-columns: repeat(var(--cols), var(--cell));
  grid-template-rows: repeat(var(--rows), var(--cell));
  gap: var(--board-gap);
  padding:calc(var(--board-gap));
  background:linear-gradient(180deg,#06314a,#022436);
  border-radius:12px;
  box-shadow: inset 0 6px 12px rgba(0,0,0,0.6);
  position:relative;
  user-select:none;
}

/* each cell (slot) */
.cell{
  width:100%;
  height:100%;
  border-radius:999px;
  background: rgba(255,255,255,0.04);
  display:flex;
  align-items:center;
  justify-content:center;
  position:relative;
  overflow:visible;
  cursor:pointer;
  transition:transform .12s ease;
}
.cell:hover{ transform: translateY(-4px) }

/* disc */
.disc{
  width:78%;
  height:78%;
  border-radius:999px;
  box-shadow: 0 6px 12px rgba(2,6,23,0.7), inset 0 -8px 14px rgba(255,255,255,0.03);
  transform-origin: center;
  transform: translateY(0) scale(0.9);
  transition: transform .18s cubic-bezier(.2,.9,.2,1);
  pointer-events:none;
  will-change:transform;
}

/* player colors */
.player1{ background: linear-gradient(180deg,#ff4d4d,#d61f1f); }
.player2{ background: linear-gradient(180deg,#f7e35b,#e0b500); }

/* subtle pop on placed */
.cell.occupied .disc{
  transform: translateY(0) scale(1);
}

/* drop animation via keyframes uses --drop-start */
@keyframes dropAnim {
  from { transform: translateY(var(--drop-start)) scale(0.95); }
  to   { transform: translateY(0) scale(1); }
}
.disc.drop {
  animation: dropAnim 350ms cubic-bezier(.22,.9,.35,1);
}

/* winning highlight */
.disc.win{
  box-shadow: 0 0 28px 6px rgba(255,255,255,0.08), 0 6px 30px rgba(0,0,0,0.6);
  filter: saturate(1.2) brightness(1.05);
  transform: scale(1.06);
}

/* footer */
.footer{
  display:flex;
  justify-content:space-between;
  align-items:center;
  margin-top:12px;
  font-size:14px;
}
.message{ min-height:20px; }
.legend{ opacity:0.9; display:flex; gap:10px; align-items:center; font-size:13px }
.dot{ display:inline-block; width:12px; height:12px; border-radius:50%;}
.red{ background:linear-gradient(180deg,#ff5b5b,#d61f1f);}
.yellow{ background:linear-gradient(180deg,#f7e35b,#e0b500);}

/* responsive scale */
@media (max-width:540px){
  :root{ --cell-size: 44px; }
  .topbar h1{ font-size:16px }
}
  </style>
  <script>
    /* Connect 4 — vanilla JS
   behavior:
   - 7 cols x 6 rows
   - click column to drop token (players alternate)
   - win/draw detection
   - reset
*/

const COLS = 7;
const ROWS = 6;

const boardEl = document.getElementById('board');
const playerNameEl = document.getElementById('playerName');
const messageEl = document.getElementById('message');
const resetBtn = document.getElementById('resetBtn');

let board = []; // rows x cols, 0 empty, 1 player1, 2 player2
let currentPlayer = 1;
let gameOver = false;

function initBoard() {
  board = Array.from({length: ROWS}, ()=> Array(COLS).fill(0));
  boardEl.innerHTML = '';
  boardEl.style.setProperty('--cols', COLS);
  boardEl.style.setProperty('--rows', ROWS);

  // create cells (row-major, but grid displays first row at top)
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;
      cell.setAttribute('role','gridcell');
      // add empty disc placeholder (keeps layout consistent)
      const disc = document.createElement('div');
      disc.className = 'disc';
      cell.appendChild(disc);

      // click should act on column (not this exact cell)
      cell.addEventListener('click', () => onColumnClick(c));
      boardEl.appendChild(cell);
    }
  }

  currentPlayer = 1;
  gameOver = false;
  playerNameEl.textContent = currentPlayer === 1 ? 'Red' : 'Yellow';
  messageEl.textContent = '';
}

function onColumnClick(col) {
  if (gameOver) return;
  // find lowest empty row in column (ROWS-1 -> 0)
  let targetRow = -1;
  for (let r = ROWS - 1; r >= 0; r--) {
    if (board[r][col] === 0) {
      targetRow = r;
      break;
    }
  }
  if (targetRow === -1) {
    // column full
    flashMessage('Column is full!');
    return;
  }

  placeDisc(targetRow, col, currentPlayer);
}

function placeDisc(row, col, player) {
  board[row][col] = player;

  // find the cell DOM element
  // the grid was rendered row-major with rows increasing top->down
  const idx = row * COLS + col;
  const cell = boardEl.children[idx];
  cell.classList.add('occupied');
  const disc = cell.querySelector('.disc');
  disc.classList.remove('player1','player2','win','drop');

  // set player color class
  disc.classList.add(player === 1 ? 'player1' : 'player2');

  // drop animation: set --drop-start based on how far it fell
  // compute pixel distance: approximate by cell height
  const cellRect = cell.getBoundingClientRect();
  // number of cells it dropped from top (for visual) — drop distance equals (row+1)*cell height
  const dropDistance = (row + 1) * (cellRect.height + parseFloat(getComputedStyle(boardEl).gap || 8));
  disc.style.setProperty('--drop-start', `${-dropDistance}px`);
  // trigger animation
  void disc.offsetWidth; // force reflow
  disc.classList.add('drop');

  // check for win
  const winCells = checkWin(row, col, player);
  if (winCells) {
    // highlight win
    winCells.forEach(([r,c]) => {
      const idx2 = r * COLS + c;
      const winCell = boardEl.children[idx2];
      winCell.querySelector('.disc').classList.add('win');
    });
    gameOver = true;
    messageEl.textContent = `Player ${player === 1 ? 'Red' : 'Yellow'} wins!`;
    playerNameEl.textContent = '-';
    return;
  }

  // check draw
  if (isBoardFull()) {
    gameOver = true;
    messageEl.textContent = `It's a draw.`; 
    playerNameEl.textContent = '-';
    return;
  }

  // swap player
  currentPlayer = currentPlayer === 1 ? 2 : 1;
  playerNameEl.textContent = currentPlayer === 1 ? 'Red' : 'Yellow';
}

function isBoardFull() {
  for (let r = 0; r < ROWS; r++) for (let c = 0; c < COLS; c++) if (board[r][c] === 0) return false;
  return true;
}

function flashMessage(txt, ms = 900) {
  const prev = messageEl.textContent;
  messageEl.textContent = txt;
  setTimeout(()=> messageEl.textContent = prev, ms);
}

/* WIN CHECK
   returns array of winning cell coords if there is a win including (row,col) else false.
   directions: horizontal (0,1), vertical (1,0), diag1 (1,1), diag2 (1,-1)
*/
function checkWin(row, col, player) {
  const dirs = [
    {dr: 0, dc: 1},
    {dr: 1, dc: 0},
    {dr: 1, dc: 1},
    {dr: 1, dc: -1},
  ];

  for (const {dr,dc} of dirs) {
    const line = [[row,col]];

    // extend forward
    let r = row + dr, c = col + dc;
    while (inBounds(r,c) && board[r][c] === player) {
      line.push([r,c]);
      r += dr; c += dc;
    }
    // extend backward
    r = row - dr; c = col - dc;
    while (inBounds(r,c) && board[r][c] === player) {
      line.unshift([r,c]);
      r -= dr; c -= dc;
    }

    if (line.length >= 4) return line.slice(0, Math.max(4, line.length)); // return winning coords
  }
  return false;
}
function inBounds(r,c){
  return r >= 0 && r < ROWS && c >= 0 && c < COLS;
}

/* reset */
resetBtn.addEventListener('click', () => initBoard());

/* keyboard support: use number keys 1-7 to drop in that column */
window.addEventListener('keydown', (e) => {
  if (e.key >= '1' && e.key <= String(COLS)) {
    onColumnClick(Number(e.key) - 1);
  } else if (e.key === 'r' || e.key === 'R') {
    initBoard();
  }
});

// initialize on load
initBoard();
  </script>
</body>
</html>